package com.oneground.keycloak.introspection;

import org.jboss.logging.Logger;
import org.keycloak.jose.jws.JWSHeader;
import org.keycloak.jose.jws.JWSInput;
import org.keycloak.jose.jws.JWSInputException;
import org.keycloak.models.ClientModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.ProtocolMapperModel;
import org.keycloak.representations.JsonWebToken;
import org.keycloak.services.resource.RealmResourceProvider;
import org.keycloak.util.JsonSerialization;
import org.keycloak.TokenVerifier;

import javax.crypto.spec.SecretKeySpec;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.FormParam;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;
import jakarta.ws.rs.ext.Provider;
/**
 * Custom JWT Token Introspection Provider that creates a REST endpoint
 * for validating zgw JWT tokens.
 * 
 * This provider handles tokens generated by external applications using HMAC-SHA256.
 * Access via: /realms/{realm}/zgw-token-introspection/introspect
 */
@Provider
public class CustomJwtIntrospectionProvider implements RealmResourceProvider {

    private static final Logger log = Logger.getLogger(CustomJwtIntrospectionProvider.class);
    private static final String CLIENT_ID_CLAIM = "client_id";
    
    private final KeycloakSession session;

    public CustomJwtIntrospectionProvider(KeycloakSession session) {
        this.session = session;
    }

    @POST
    @Path("introspect")
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(MediaType.APPLICATION_JSON)
    public Response introspect(@FormParam("token") String token) {
        
        try {
            log.debug("Zgw token introspection request");
            
            // Validate request parameters
            if (token == null || token.trim().isEmpty()) {
                return Response.ok(createInactiveTokenResponse()).build();
            }
                        
            // Parse and validate the token
            Map<String, Object> tokenInfo = validateCustomJwt(token);
            
            return Response.ok(tokenInfo).build();
            
        } catch (Exception e) {
            log.errorf(e, "Error during custom JWT introspection: %s", e.getMessage());
            return Response.ok(createInactiveTokenResponse()).build();
        }
    }

    /**
     * Validates a custom JWT token and returns token information.
     */
    private Map<String, Object> validateCustomJwt(String rawToken) {
        try {
            // Step 1: Parse the JWT token
            JWSInput jwsInput = parseJwtToken(rawToken);
            if (jwsInput == null) {
                log.warn("Failed to parse token as JWT");
                return createInactiveTokenResponse();
            }

            // Step 2: Deserialize once and extract client_id from token claims
            String payload = jwsInput.readContentAsString();
            JsonWebToken token = JsonSerialization.readValue(payload, JsonWebToken.class);
            String tokenClientId = extractClientId(token);
            if (tokenClientId == null || tokenClientId.trim().isEmpty()) {
                log.debug("No client_id found in JWT token");
                return createInactiveTokenResponse();
            }

            // Step 3: Find the client in the current realm
            RealmModel realm = session.getContext().getRealm();
            ClientModel client = realm.getClientByClientId(tokenClientId);
            if (client == null) {
                log.debugf("Client with ID '%s' not found in realm", tokenClientId);
                return createInactiveTokenResponse();
            }

            // Step 4: Get client secret
            String clientSecret = client.getSecret();
            if (clientSecret == null || clientSecret.trim().isEmpty()) {
                log.warnf("No secret configured for client '%s'", tokenClientId);
                return createInactiveTokenResponse();
            }

            // Step 5: Verify the JWT token signature and claims
            if (!verifyJwtToken(rawToken, jwsInput, clientSecret, token)) {
                log.debugf("JWT token verification failed for client '%s'", tokenClientId);
                return createInactiveTokenResponse();
            }

            // Step 6: Create successful introspection response
            return createActiveTokenResponse(token, client);

        } catch (Exception e) {
            log.errorf(e, "Error during token validation: %s", e.getMessage());
            return createInactiveTokenResponse();
        }
    }

    /**
     * Parses the JWT token string into a JWSInput object.
     */
    private JWSInput parseJwtToken(String token) {
        try {
            return new JWSInput(token);
        } catch (JWSInputException e) {
            log.debugf("Failed to parse JWT token: %s", e.getMessage());
            return null;
        }
    }

    /**
     * Extracts the client_id claim from the deserialized JWT token.
     */
    private String extractClientId(JsonWebToken token) {
        try {
            return (String) token.getOtherClaims().get(CLIENT_ID_CLAIM);
        } catch (Exception e) {
            log.debugf("Failed to extract client_id from JWT claims: %s", e.getMessage());
            return null;
        }
    }

    /**
     * Verifies the JWT token signature and validates standard claims.
     */
    private boolean verifyJwtToken(String rawToken, JWSInput jwsInput, String clientSecret, JsonWebToken token) {
        try {
            // Verify the algorithm is HMAC-SHA256
            JWSHeader header = jwsInput.getHeader();
            if (!org.keycloak.crypto.Algorithm.HS256.equals(header.getAlgorithm().name())) {
                log.warn("JWT token uses unsupported algorithm. Expected HS256");
                return false;
            }

            // Verify the signature
            try {
                TokenVerifier<JsonWebToken> verifier = TokenVerifier.create(rawToken, JsonWebToken.class)
                    .secretKey(new SecretKeySpec(clientSecret.getBytes(StandardCharsets.UTF_8), "HmacSHA256"));
                verifier.verify();
            } catch (Exception e) {
                log.debugf("JWT signature verification failed: %s", e.getMessage());
                return false;
            }

            // Validate expiration claim
            Long expiration = token.getExp();
            if (expiration == null) {
                log.warn("JWT token is missing the 'exp' claim. This effectively makes the token non-expiring; for security, issue tokens with a short expiration (e.g., 1-5 minutes)");
            }

            // Validate standard temporal claims (exp/nbf) against current time
            if (!token.isActive(30)) {
                log.debug("JWT token is not active (expired or not yet valid)");
                return false;
            }

            return true;

        } catch (Exception e) {
            log.debugf("Unexpected exception during JWT verification: %s", e.getMessage());
            return false;
        }
    }

    /**
     * Creates an inactive token response for invalid tokens.
     */
    private Map<String, Object> createInactiveTokenResponse() {
        Map<String, Object> response = new HashMap<>();
        response.put("active", false);
        return response;
    }

    /**
     * Creates an active token response with token information.
     */
    private Map<String, Object> createActiveTokenResponse(JsonWebToken token, ClientModel client) {
        Map<String, Object> response = new HashMap<>();
        response.put("active", true);
        
        // Standard OAuth2 introspection claims
        response.put("client_id", client.getClientId());
        
        // Set expiration
        Long expiration = token.getExp();
        if (expiration != null) {
            response.put("exp", expiration);
        }
        
        // Set issued at time if present
        Long issuedAt = token.getIat();
        if (issuedAt != null) {
            response.put("iat", issuedAt);
        }

        // Set not-before time if present
        Long notBefore = token.getNbf();
        if (notBefore != null) {
            response.put("nbf", notBefore);
        }
        
        // Set subject if present
        if (token.getSubject() != null) {
            response.put("sub", token.getSubject());
        }
        
        // Set token id if present
        String tokenId = token.getId();
        if (tokenId != null && !tokenId.isEmpty()) {
            response.put("jti", tokenId);
        }

        // Set issuer
        if (token.getIssuer() != null) {
            response.put("iss", token.getIssuer());
        }

        // Set audience if present
        String[] audience = token.getAudience();
        if (audience != null && audience.length > 0) {
            if (audience.length == 1) {
                response.put("aud", audience[0]);
            } else {
                response.put("aud", Arrays.asList(audience));
            }
        }

        // Add custom claims
        if (token.getOtherClaims() != null) {
            response.putAll(token.getOtherClaims());
        }
        
        // Add claims from client's OIDC Hardcoded Claim mappers
        applyHardcodedProtocolMappers(response, client);
        
        log.debugf("Successfully introspected custom JWT for client '%s'", client.getClientId());
        return response;
    }


    private void applyHardcodedProtocolMappers(Map<String, Object> response, ClientModel client) {
        client.getProtocolMappersStream()
            .filter(this::isOidcHardcodedClaimMapper)
            .forEach(mapper -> {
                Map<String, String> cfg = mapper.getConfig();
                if (cfg == null) {
                    return;
                }
                String claimName = cfg.get("claim.name");
                String claimValue = cfg.get("claim.value");

                if (claimName == null || claimName.isEmpty() || claimValue == null) {
                    return;
                }
                response.put(claimName, claimValue);
            });
    }

    private boolean isOidcHardcodedClaimMapper(ProtocolMapperModel mapper) {
        if (mapper == null) {
            return false;
        }

        String providerId = mapper.getProtocolMapper();
        return "oidc-hardcoded-claim-mapper".equals(providerId);
    }

    @Override
    public Object getResource() {
        return this;
    }

    @Override
    public void close() {
        // No cleanup needed
    }
}